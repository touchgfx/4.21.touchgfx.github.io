"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[404],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},44035:function(e,t,n){var a=n(67294),i=n(25026);t.Z=function(e){const t=e.noShadow||!1,n=e.width,r=e.height,o=(0,i.Z)(e.imageSource);return t?a.createElement("div",{className:"figure noshadow"},a.createElement("a",{href:o,target:"_blank"},a.createElement("img",{width:n,height:r,src:o})),a.createElement("p",null,e.children)):a.createElement("div",{className:"figure"},a.createElement("a",{href:o,target:"_blank"},a.createElement("img",{width:n,height:r,src:o})),a.createElement("p",null,e.children))}},29415:function(e,t,n){var a=n(67294),i=n(88678);const r=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class o extends a.Component{render(){return a.createElement(i.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:r},this.props.children)}}t.Z=o},88678:function(e,t,n){var a=n(67294);class i extends a.Component{render(){const e=`highlight highlight-${this.props.type}`;return a.createElement("div",{className:e},a.createElement("div",{className:"highlight-heading"},a.createElement("h5",null,a.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),a.createElement("div",{className:"highlight-content"},this.props.children))}}t.Z=i},31217:function(e,t,n){var a=n(67294);class i extends a.Component{render(){return a.createElement("code",null,this.props.children)}}t.Z=i},93054:function(e,t,n){var a=n(67294),i=n(88678);const r=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class o extends a.Component{render(){return a.createElement(i.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:r},this.props.children)}}t.Z=o},87169:function(e,t,n){n.r(t),n.d(t,{assets:function(){return w},contentTitle:function(){return k},default:function(){return x},frontMatter:function(){return b},metadata:function(){return v},toc:function(){return y}});var a=n(3905),i=n(44035),r=n(29415),o=n(31217),l=n(39130),s=n(93054),p=Object.defineProperty,d=Object.defineProperties,u=Object.getOwnPropertyDescriptors,c=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable,g=(e,t,n)=>t in e?p(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,f=(e,t)=>{for(var n in t||(t={}))m.call(t,n)&&g(e,n,t[n]);if(c)for(var n of c(t))h.call(t,n)&&g(e,n,t[n]);return e};const b={id:"canvas-widgets",title:"Canvas Widgets"},k=void 0,v={unversionedId:"development/ui-development/touchgfx-engine-features/canvas-widgets",id:"development/ui-development/touchgfx-engine-features/canvas-widgets",title:"Canvas Widgets",description:"",source:"@site/docs/development/ui-development/touchgfx-engine-features/canvas-widgets.mdx",sourceDirName:"development/ui-development/touchgfx-engine-features",slug:"/development/ui-development/touchgfx-engine-features/canvas-widgets",permalink:"/4.21/zh-TW/docs/development/ui-development/touchgfx-engine-features/canvas-widgets",draft:!1,tags:[],version:"current",frontMatter:{id:"canvas-widgets",title:"Canvas Widgets"},sidebar:"docs",previous:{title:"Custom Widgets",permalink:"/4.21/zh-TW/docs/development/ui-development/touchgfx-engine-features/custom-widgets"},next:{title:"Dynamic Bitmaps",permalink:"/4.21/zh-TW/docs/development/ui-development/touchgfx-engine-features/dynamic-bitmaps"}},w={},y=[{value:"Using Canvas Widgets",id:"using-canvaswidgets",level:2},{value:"Memory Allocation and Usage",id:"memory-allocation-and-usage",level:2},{value:"Memory Allocation in TouchGFX Designer",id:"memory-allocation-in-touchgfx-designer",level:3},{value:"Memory Allocation in User Code",id:"memory-allocation-in-user-code",level:3},{value:"The CWR Coordinate System",id:"the-cwr-coordinate-system",level:2},{value:"Custom Canvas Widgets",id:"custom-canvas-widgets",level:2},{value:"Painters",id:"painters-painters",level:2},{value:"Painter classes",id:"painters-classes",level:3},{value:"Tiled bitmaps",id:"painters-tiled",level:3},{value:"Custom Painters",id:"custom-painters",level:2},{value:"Color painters",id:"painters-color",level:3},{value:"Changing the framebuffer",id:"painters-framebuffer",level:3},{value:"Custom Containers on rotated displays",id:"painters-custom",level:3},{value:"Filling Rule",id:"filling-rule",level:2}],N={toc:y};function x(e){var t,n=e,{components:p}=n,g=((e,t)=>{var n={};for(var a in e)m.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&c)for(var a of c(e))t.indexOf(a)<0&&h.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=f(f({},N),g),d(t,u({components:p,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Canvas Widgets and the Canvas Widget Renderer are a powerful and versatile add-on to TouchGFX which provides nice smooth, anti-aliased drawing of geometric shapes using relatively little memory while maintaining high performance. However, rendering geometrical shapes must be seen as a quite expensive operation and can easily strain the microcontrollers resources if not used carefully."),(0,a.kt)("p",null,"The Canvas Widget Renderer (hereafter referred to as CWR) is a general graphics API, providing optimized drawing for primitives, automatically eliminating most superfluous drawings. CWR is used by TouchGFX for drawing complex geometric shapes. Geometric shapes are defined by Canvas Widgets. TouchGFX comes with a number of supported Canvas Widgets but just like normal widgets you can make your own custom Canvas Widget to match your needs. Where a Canvas Widget defines the geometric shape of a figure to be drawn by the CWR, the actual color of each pixel inside the figure is defined by an associated Painter class. Again, TouchGFX comes with a number of Painters but you can make your own custom Painters to match your needs."),(0,a.kt)("h2",f({},{id:"using-canvaswidgets"}),"Using Canvas Widgets"),(0,a.kt)("p",null,"Other widgets in TouchGFX have their sizes set automatically. A bitmap widget, for example, will automatically get the width and height of the contained bitmap. It is therefore enough to use ",(0,a.kt)("inlineCode",{parentName:"p"},"setXY()")," on the bitmap widget to place the bitmap on the display."),(0,a.kt)("p",null,"Canvas Widgets do not have a default size which can be determined automatically and set initially. Care must be taken to not only position, but also size the widget correctly, otherwise the width and height of the Canvas Widget will be zero, and nothing will be drawn on the display."),(0,a.kt)("p",null,"So, instead of using ",(0,a.kt)("inlineCode",{parentName:"p"},"setXY()"),", use ",(0,a.kt)("inlineCode",{parentName:"p"},"setPosition()")," to place and size the canvas widget. See also Custom Canvas Widgets below for an example on how to create and use a custom canvas widget."),(0,a.kt)("p",null,"Once the position and size of the Canvas Widget has been set, a geometrical shape can be drawn inside it. The coordinate system will have (0, 0) in the upper left corner of the widget (not the display), the X axis stretches to the right and the Y axis stretches downwards."),(0,a.kt)("p",null,"Canvas widgets are also supported in TouchGFX Designer, and make the usage simple and has automatic memory requirement calculation and automatic memory allocation."),(0,a.kt)("p",null,"Available Canvas Widgets in the TouchGFX Designer:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",f({parentName:"li"},{href:"../ui-components/shapes/line"}),"Line")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",f({parentName:"li"},{href:"../ui-components/shapes/circle"}),"Circle")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",f({parentName:"li"},{href:"../ui-components/shapes/shape"}),"Shape")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",f({parentName:"li"},{href:"../ui-components/progress-indicators/line-progress"}),"Line Progress")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",f({parentName:"li"},{href:"../ui-components/progress-indicators/circle-progress"}),"Circle Progress"))),(0,a.kt)("p",null,"Using these widgets via TouchGFX Designer, makes placement and size adjustment much easier by showing how the widget will look at run time."),(0,a.kt)("h2",f({},{id:"memory-allocation-and-usage"}),"Memory Allocation and Usage"),(0,a.kt)("p",null,"To produce nice anti-aliased complex geometrical shapes additional memory is required. For this CWR has to have a special allocated memory buffer that is used during rendering. CWR, as the rest of TouchGFX, has no dynamic memory allocation."),(0,a.kt)("h3",f({},{id:"memory-allocation-in-touchgfx-designer"}),"Memory Allocation in TouchGFX Designer"),(0,a.kt)("p",null,"When adding a widget to the canvas of a Screen, a memory buffer is automatically generated. The size of the buffer is based upon the width of the Screen with the following formula (Width ","\xd7"," 3) ","\xd7"," 5.\nThis is however not always the ideal buffer size for all scenarios. Therefore the buffer size can be overridden has shown in the image below."),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/screen-canvas-buffer-override-4.17.png",mdxType:"Figure"},"Canvas buffer size being overridden in Screen properties"),(0,a.kt)(s.Z,{mdxType:"Note"},"It is also possible to generate a memory buffer, for screens that doesn't use Canvas Widgets, by using the override functionality described above. This is useful when creating Canvas Widgets in User Code."),(0,a.kt)("h3",f({},{id:"memory-allocation-in-user-code"}),"Memory Allocation in User Code"),(0,a.kt)("p",null,"If you don't use the TouchGFX Designer to allocate a memory buffer for\nscreens that uses Canvas Widgets, you must manually setup a buffer.\nIt is recommended to do this in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Screen::setupScreen")," method."),(0,a.kt)("p",null,"Add this to your Screen class definition as private members:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"private:\n  static const uint16_t CANVAS_BUFFER_SIZE = 3600;\n  static uint8_t canvasBuffer[CANVAS_BUFFER_SIZE]\n")),(0,a.kt)("p",null,"Then in ",(0,a.kt)("inlineCode",{parentName:"p"},"setupScreen()")," method of ",(0,a.kt)("inlineCode",{parentName:"p"},"ScreenView.cpp")," the following line setting up the buffer can be added."),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"void ScreenView::setupScreen()\n{\n    ...\n    CanvasWidgetRenderer::setupBuffer(canvasBuffer, CANVAS_BUFFER_SIZE);\n    ...\n}\n")),(0,a.kt)("p",null,"And in the destrcutor ",(0,a.kt)("inlineCode",{parentName:"p"},"~ScreenView()")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"ScreenView.hpp")," the following line resetting the buffer can be added."),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"virtual ~ScreenView()\n{\n    touchgfx::CanvasWidgetRenderer::resetBuffer();\n}\n")),(0,a.kt)("p",null,"The amount of CWR memory needed depends on the maximum size of the shapes that are to be drawn in the application. You can, however, reserve less memory than required by the most complex shape. To handle this situation, the CWR splits the drawing of shapes into smaller framebuffer parts resulting in slightly longer rendering time, as shapes in these cases will sometimes have to be rendered more than once.\nIt is possible to investigate the memory consumption closer and fine-tune it when running in simulator mode. Simply add the following function call to your main.cpp:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"CanvasWidgetRenderer::setWriteMemoryUsageReport(true);\n")),(0,a.kt)("p",null,"Now whenever a draw operation finishes, CWR will report (print in the console) how much memory was required. For canvas_widget_example this could be \u201cCWR requires 3604 bytes\u201d (for the first draw operation) followed by \u201cCWR requires 7932 bytes (4328 bytes missing)\u201d (for the second draw operation).\nEven though it appears that CWR does not have enough memory (4328 bytes missing in this case) the application runs fine. This is because CWR detects that too little memory is available to complete the complex draw operation in a single run. Instead, it splits the draw operation into two separate draw operations and the shape will be drawn just fine but will require more time to render."),(0,a.kt)("p",null,"Setting the correct memory buffer size is therefore a trade off between memory and performance (rendering time). A good starting value is usually around 3000, but using the above technique, a better value can often be determined. If the shape is too complex and the allocated memory buffer is way too small, part of the shape will not be drawn (some vertical pixel lines will be skipped) and it is possible that nothing is drawn at all. In any case rendering time will increase a lot."),(0,a.kt)("p",null,"This means that if you want your application to render the CWR drawing at maximum speed you need to allocate the requested amount of memory. But if you can go with a slower rendering time it is perfectly okay to reduce the memory buffer."),(0,a.kt)("h2",f({},{id:"the-cwr-coordinate-system"}),"The CWR Coordinate System"),(0,a.kt)("p",null,"The coordinate system in TouchGFX is normally used to address pixels for positioning bitmaps on the display. Bitmaps, texts and other graphic elements are all placed in a coordinate system, where (0,0) is the upper left hand pixel, the x-axis extends to the right and the y-axis extends downwards. In CWR it is not enough to be able to address pixels using integers, though this might be enough in special cases, this is far from enough in general. To demonstrate this, consider a circle with line width 1, which must fit precisely inside a box of 5 by 5 pixels. The center of this circle must be at (2.5, 2.5) and the radius must be 2 (the line is drawn .5 out from both sides of the circumference), so fractions are required for the center coordinate. Similarly, if the circle should fit inside a box of 6 by 6 pixels, the center must be at (3, 3) and the radius must be 2.5, so here fractions are required for the radius."),(0,a.kt)("p",null,"This new way of addressing coordinates for drawing graphics, means that the center of the pixel at (0,0) has CWR coordinate (0.5, 0.5). Hence, the box containing the pixel in the upper left corner of the screen has the following outline: (0,0) -> (1,0) -> (1,1) -> (0,1) -> (0,0)."),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/cwr-coordinate-system.png",mdxType:"Figure"},"CWR coordinate system for pixel at (0,0)"),(0,a.kt)("p",null,"Though this might seem confusing at first, it quickly becomes very natural. Where the coordinate system for bitmaps address the pixels, the same coordinate for Canvas Widgets address the gap just before and above the pixel."),(0,a.kt)("p",null,"Since circles are shapes that often will have to be moved half a pixel to place the center correctly, the function ",(0,a.kt)("inlineCode",{parentName:"p"},"Circle::setPixelCenter()")," will place the circle center at the center of the given pixel, i.e. half a pixel further to the right and down, compared to the coordinates specified."),(0,a.kt)("h2",f({},{id:"custom-canvas-widgets"}),"Custom Canvas Widgets"),(0,a.kt)("p",null,"Implementing a custom Canvas Widget requires an implementation of a new class with the following functions:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"virtual bool drawCanvasWidget(const Rect& invalidatedArea) const;\nvirtual Rect getMinimalRect() const;\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"drawCanvasWidget()")," must draw whatever the custom widget needs to draw and ",(0,a.kt)("inlineCode",{parentName:"p"},"getMinimalRect()")," should return the actual rectangle in the Widget which contains the geometrical shape."),(0,a.kt)(s.Z,{mdxType:"Note"},"The reason for having ",(0,a.kt)(o.Z,{mdxType:"InlineCode"},"getMinimalRect()")," is that a geometrical shape can be moved around inside its widget and it is often impractical to resize and reposition the widget whenever the shape changes to only invalidate the smallest possible area.",(0,a.kt)("p",null,"  A dummy implementation of ",(0,a.kt)(o.Z,{mdxType:"InlineCode"},"getMinimalRect()")," could simply ",(0,a.kt)(o.Z,{mdxType:"InlineCode"},"return rect;"),", that is the size of the widget, but that would cause the entire area covered by the canvas widget to be redrawn, and not just the part of the canvas widget containing the geometrical shape. Very often, the geometrical shape occupies only a small part of the canvas widget.")),(0,a.kt)("p",null,"Canvas Widgets all use the Canvas class, which encapsulates the Canvas Widget Renderer as described above. CWR has many optimizations applied automatically, though awareness of your geometrical shape in relation to the invalidated area, and avoiding unnecessary drawing outside the invalidated area, is always a good way to boost performance."),(0,a.kt)("p",null,"A rough implementation of a diamond shaped square inside a 10x10 box could look something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"#include <touchgfx/widgets/canvas/CanvasWidget.hpp>\n#include <touchgfx/widgets/canvas/Canvas.hpp>\n\nusing namespace touchgfx;\n\nclass Diamond10x10 : public CanvasWidget\n{\npublic:\n  virtual Rect getMinimalRect() const\n  {\n    return Rect(0,0,10,10);\n  }\n  virtual bool drawCanvasWidget(const Rect& invalidatedArea) const\n  {\n    Canvas canvas(this, invalidatedArea);\n    canvas.moveTo(5,0);\n    canvas.lineTo(10,5);\n    canvas.lineTo(5,10);\n    canvas.lineTo(0,5);\n    return canvas.render(); // Shape is automatically closed\n  }\n};\n")),(0,a.kt)(s.Z,{mdxType:"Note"},"Again, be careful that ",(0,a.kt)(o.Z,{mdxType:"InlineCode"},"getMinimalRect()")," returns to correct rectangle, or the graphics on screen might be wrong."),(0,a.kt)("p",null,"In order to see the Diamond10x10 on the display, the color must be set up by passing a Painter to the diamond. Read more about Painters in the next section. Also, the Diamond10x10 must be placed and sized correctly. This could look similar to this:"),(0,a.kt)("p",null,"In the header file declare"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"Diamond10x10 box;\nPainterRGB565 myPainter; // For 16bpp displays\n")),(0,a.kt)("p",null,"and in the code you should have something like this in setupScreen():"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"myPainter.setColor(Color::getColorFromRGB(0xFF, 0x0, 0x0));\nbox.setPosition(100,100,10,10);\nbox.setPainter(myPainter);\nadd(box);\n")),(0,a.kt)("h2",f({},{id:"painters-painters"}),"Painters"),(0,a.kt)("p",null,"A Painter defines a coloring scheme to fill a Canvas Widget object, thus painters are needed to make shapes visible. A painter can supply a single color for all pixels, e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"PainterRGB565"),", or copy each pixel from a supplied bitmap, e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"PainterRGB565Bitmap"),". Since a painter writes the pixels directly to the framebuffer, the selected painter must match the format of the framebuffer or dynamic bitmap. TouchGFX comes with painters for all supported displays with painters specific for a solid color, or drawing a bitmap."),(0,a.kt)("h3",f({},{id:"painters-classes"}),"Painter classes"),(0,a.kt)("p",null,"The following table lists the available painters in TouchGFX. When you\nuse Canvas Widgets with the TouchGFX Designer, the Designer will\nselect the correct painter, but if you write code yourself that uses\nCanvas Widgets, you must select a suitable painter."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",f({parentName:"tr"},{align:null}),"Framebuffer format"),(0,a.kt)("th",f({parentName:"tr"},{align:null}),"Color Painter"),(0,a.kt)("th",f({parentName:"tr"},{align:null}),"Bitmap painters"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"BW"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterBW"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterBWBitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"GRAY2"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterGRAY2"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterGRAY2Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"GRAY4"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterGRAY4"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterGRAY4Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"ABGR2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterABGR2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterABGR2222Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"ARGB2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterARGB2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterARGB2222Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"BGRA2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterBGRA2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterBGRA2222Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGBA2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGBA2222"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGBA2222Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGB565"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB565"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB565Bitmap, PainterRGB565L8Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGB888"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB888"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB888Bitmap, PainterRGB888L8Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"ARGB8888"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterARGB8888"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterARGB8888Bitmap, PainterARGB8888L8Bitmap")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"XRGB8888"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterXRGB8888"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterXRGB8888Bitmap, PainterXRGB8888L8Bitmap")))),(0,a.kt)("p",null,"The bitmap painters support various bitmap formats:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",f({parentName:"tr"},{align:null}),"Painter"),(0,a.kt)("th",f({parentName:"tr"},{align:null}),"Supported bitmap formats"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterBWBitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"BW, BW_RLE")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterGRAY2Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"GRAY2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterGRAY4Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"GRAY4")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterABGR2222Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"ABGR2222")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterARGB2222Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"ARGB2222")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterBGRA2222Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"BGRA2222")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGBA2222Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGBA2222")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB565Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGB565, ARGB8888")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB565L8Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"L8_RGB565, L8_RGB888, L8_ARGB8888")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB888Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGB888, ARGB8888")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterRGB888L8Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"L8_RGB565, L8_RGB888, L8_ARGB8888")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterARGB8888Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGB565, RGB888, ARGB8888")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterARGB8888L8Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"L8_RGB565, L8_RGB888, L8_ARGB8888")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterXRGB8888Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"RGB565 (no transparency), RGB888, ARGB8888")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",f({parentName:"tr"},{align:null}),"PainterXRGB8888L8Bitmap"),(0,a.kt)("td",f({parentName:"tr"},{align:null}),"L8_RGB565, L8_RGB888, L8_ARGB8888")))),(0,a.kt)("h3",f({},{id:"painters-tiled"}),"Tiled bitmaps"),(0,a.kt)("p",null,"Painters that draw pixels from a bitmap puts the bitmap in upper left\ncorner of the Canvas Widget. The pixels of the shape that are outside\nof the bitmap dimension is not drawn."),(0,a.kt)("p",null,"The bitmap painters can be configured to repeat the widget (tiled) to\ncover the whole shape."),(0,a.kt)("p",null,"Tiling is enabled by calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"setTiled(bool)")," method on your painter:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"    PainterRGB888Bitmap bitmapPainter;\n    ...\n    bitmapPainter.setBitmap(touchgfx::Bitmap(BITMAP_BLUE_LOGO_TOUCHGFX_LOGO_ID));\n    bitmapPainter.setTiled(true);\n")),(0,a.kt)("p",null,"Tiling can not be enabled in the Designer."),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/tiled-bitmap-painters.png",mdxType:"Figure"},"An application showing an Image, Circle with bitmap painter, and Circle with tiling bitmap painter."),(0,a.kt)("h2",f({},{id:"custom-painters"}),"Custom Painters"),(0,a.kt)("p",null,"Even though TouchGFX comes with a set of predefined painter classes covering most use case scenarios, custom painters can also be implemented."),(0,a.kt)("p",null,"In this section we will give a few examples, that can be used as\ninspiration. The examples are for 16bpp RGB565 only. Slight\nmodifications must be done for other framebuffer formats."),(0,a.kt)("p",null,"A custom painter is just a subclass of the AbstractPainter\nclass. Painters for 16bpp (RGB565) framebuffers can use the\nAbstractPainterRGB565 class as superclass. Painters for 24bpp (RGB888)\nframebuffers can use AbstractPainterRGB888 as superclass."),(0,a.kt)("p",null,"These super classes are abstract classes. The custom painter class must implement the method:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"    virtual void paint(uint8_t* destination, int16_t offset, int16_t widgetX, int16_t widgetY, int16_t count, uint8_t alpha) const = 0;\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"destination")," points to the start position in the framebuffer (the\nleft edge of the widget).",(0,a.kt)("br",{parentName:"p"}),"\n","The ",(0,a.kt)("em",{parentName:"p"},"offset")," is how many pixels from this start position to put the first pixel.",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("em",{parentName:"p"},"widgetX"),", ",(0,a.kt)("em",{parentName:"p"},"widgetY")," are the coordinates of the first pixel relative to widget (given in the framebuffer coordinate system).",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("em",{parentName:"p"},"count")," is the number of pixels to draw with the specified ",(0,a.kt)("em",{parentName:"p"},"alpha"),"."),(0,a.kt)("p",null,"The Canvas Widgets will call this method many times, so it is very\nimportant that the implementation of ",(0,a.kt)("em",{parentName:"p"},"paint")," is not slow. If the\nCanvas Widget is not updated often, this is less important."),(0,a.kt)("h3",f({},{id:"painters-color"}),"Color painters"),(0,a.kt)("p",null,"The simplest painter just writes a fixed color to the framebuffer. Here is how to implement that:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"#include <touchgfx/widgets/canvas/AbstractPainterRGB565.hpp>\nusing namespace touchgfx;\nclass RedPainter : public AbstractPainterRGB565\n{\npublic:\n    virtual void paint(uint8_t* destination, int16_t offset, int16_t widgetX, int16_t widgetY, int16_t count, uint8_t alpha) const\n    {\n        uint16_t* framebuffer = reinterpret_cast<uint16_t*>(destination) + offset; // Address of first pixel to paint\n        const uint16_t* const lineend = framebuffer + count; // Address of last pixel to paint\n        const uint16_t redColor565 = 0xF800;  // Full red in RGB565\n        do\n        {\n            *framebuffer = redColor565;\n        } while (++framebuffer < lineend);\n    }\n};\n")),(0,a.kt)("p",null,"Remember to create an instance of your painter and assign it to your Canvas widget. Add a member of the painter type to your class:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"Circle myCircle;\nRedPainter myPainter;\n")),(0,a.kt)("p",null,"and in the code you should have something like this in setupScreen():"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"...\nmyCircle.setPainter(myPainter);\n...\n")),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/red-painter.png",mdxType:"Figure"},"The RedPainter painting a Circle. On the right a magnified part."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"RedPainter")," class above ignores the alpha parameter. This makes\nthe edges harsh (no alpha-blending) as all pixels are made fully\nred. We can improve this with a slight code update where we use the\n",(0,a.kt)("em",{parentName:"p"},"alpha")," parameter to do blending if needed:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp",metastring:"{13-20}","{13-20}":!0}),"#include <touchgfx/widgets/canvas/AbstractPainterRGB565.hpp>\nusing namespace touchgfx;\nclass AlphaRedPainter : public AbstractPainterRGB565\n{\npublic:\n    virtual void paint(uint8_t* destination, int16_t offset, int16_t widgetX, int16_t widgetY, int16_t count, uint8_t alpha) const\n    {\n        uint16_t* framebuffer = reinterpret_cast<uint16_t*>(destination) + offset; // Address of first pixel to paint\n        const uint16_t* const lineend = framebuffer + count;\n        const uint16_t redColor565 = 0xF800;  // Full red in RGB565\n        do\n        {\n            if (alpha == 0xFF)\n            {\n                *framebuffer = redColor565; // Write red to framebuffer\n            }\n            else\n            {\n                *framebuffer = alphaBlend(redColor565, *framebuffer, alpha); // Blend red with the framebuffer color\n            }\n        } while (++framebuffer < lineend);\n    }\n};\n")),(0,a.kt)("p",null,"The function ",(0,a.kt)("em",{parentName:"p"},"alphaBlend")," blends two RGB565 pixels with a given alpha\nfor the first pixel. The function is provided by the super class\n",(0,a.kt)("em",{parentName:"p"},"AbstractPainterRGB565"),". The circle now has smooth edges with this code:"),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/red-alpha-painter.png",mdxType:"Figure"},"The RedAlphaPainter painting a Circle. On the right a magnified part showing alpha blending."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"WidgetX")," and ",(0,a.kt)("em",{parentName:"p"},"WidgetY")," parameters can be used to restrict the\ndrawing to certain areas. Here is for example a painter that only\ndraws on every other horizontal line. The ",(0,a.kt)("em",{parentName:"p"},"WidgetY")," is used to control\nthat:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp",metastring:"{8-11}","{8-11}":!0}),"#include <touchgfx/widgets/canvas/AbstractPainterRGB565.hpp>\nusing namespace touchgfx;\nclass StripePainter : public AbstractPainterRGB565\n{\npublic:\n    virtual void paint(uint8_t* destination, int16_t offset, int16_t widgetX, int16_t widgetY, int16_t count, uint8_t alpha) const\n    {\n        if ((widgetY & 2) == 0)\n        {\n            return; // Do not draw anything on line 0,1, 4,5, 8,9, etc.\n        }\n        uint16_t* framebuffer = reinterpret_cast<uint16_t*>(destination) + offset;\n        const uint16_t* const lineend = framebuffer + count;\n        if (alpha == 0xFF)\n        {\n            do\n            {\n                *framebuffer = 0xF800;\n            } while (++framebuffer < lineend);\n        }\n        else\n        {\n            do\n            {\n                *framebuffer = alphaBlend(0xF800, *framebuffer, alpha);\n            } while (++framebuffer < lineend);\n        }\n    }\n};\n")),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/stripe-painter.png",mdxType:"Figure"},"The StripePainter painting a Circle. On the right a magnified part."),(0,a.kt)("h3",f({},{id:"painters-framebuffer"}),"Changing the framebuffer"),(0,a.kt)("p",null,"The painter in this section does not paint a specific content to the\nframebuffer, but changes the framebuffer to be gray-scale. It does\nthis by reading the pixel value in the framebuffer (written by the\nWidgets that are in the background of the Circle), extracting the\ngreen component, using this to create a gray color (same value for\nred, green, blue), and writing that back to the framebuffer."),(0,a.kt)("p",null,"Many similar techniques can be developed using this principle of reading and modifying the framebuffer."),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp",metastring:"{13-14}","{13-14}":!0}),"#include <touchgfx/widgets/canvas/AbstractPainterRGB565.hpp>\n#include <touchgfx/Color.hpp>\nusing namespace touchgfx;\nclass GrayscalePainter : public AbstractPainterRGB565\n{\npublic:\n    virtual void paint(uint8_t* destination, int16_t offset, int16_t widgetX, int16_t widgetY, int16_t count, uint8_t alpha) const\n    {\n        uint16_t* framebuffer = reinterpret_cast<uint16_t*>(destination) + offset;\n        const uint16_t* const lineend = framebuffer + count;\n        do\n        {\n            const uint8_t green = Color::getGreenFromRGB565(*framebuffer) & 0xF8; // Keep only 5 bits of the green\n            const uint16_t color565 = LCD16bpp::getNativeColorFromRGB(green, green, green);\n            if (alpha == 0xFF)\n            {\n                *framebuffer = color565;\n            }\n            else\n            {\n                *framebuffer = alphaBlend(color565, *framebuffer, alpha);\n            }\n        } while (++framebuffer < lineend);\n    }\n};\n")),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/gray-painter.png",mdxType:"Figure"},"Original background on the left. On the right the Circle painter has changed the inner pixels in the circle to gray-scale."),(0,a.kt)("h3",f({},{id:"painters-custom"}),"Custom Containers on rotated displays"),(0,a.kt)("p",null,"If your application is using a rotated display, the custom container\ncode must take this into account, if it is using the coordinates in\nthe painting."),(0,a.kt)("p",null,"Here is the StripePainter used with a rotated display:"),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/stripe-painter-rotate90.png",mdxType:"Figure"},"The StripePainter painting a Circle. On the right a magnified part."),(0,a.kt)("p",null,"The Image, text, and the Button has been rotated by the TouchGFX\nengine, but we see that the stripes are now perpendicular to the text,\nwhere it is supposed to parallel. The lines have not been rotated.",(0,a.kt)("br",{parentName:"p"}),"\n","The problem is that the framebuffer is not rotated, so as the painter\npaints in sequential addresses (pixels in the framebuffer), the lines\nare oriented as before (not rotated)."),(0,a.kt)("p",null,"We can fix that by using the ",(0,a.kt)("em",{parentName:"p"},"WidgetX")," to decide if we are painting or\nnot. The ",(0,a.kt)("em",{parentName:"p"},"widgetX")," and ",(0,a.kt)("em",{parentName:"p"},"widgetY")," parameters are given in the\nframebuffer coordinate system. This means that ",(0,a.kt)("em",{parentName:"p"},"widgetX")," grows when we\ngo down on the display and corresponds to y in the display coordinate\nsystem."),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp",metastring:"{15-18,25-28}","{15-18,25-28}":!0}),"#include <touchgfx/widgets/canvas/AbstractPainterRGB565.hpp>\n#include <touchgfx/Color.hpp>\nusing namespace touchgfx;\nclass StripePainterRotate90 : public AbstractPainterRGB565\n{\npublic:\n    virtual void paint(uint8_t* destination, int16_t offset, int16_t widgetX, int16_t widgetY, int16_t count, uint8_t alpha) const\n    {\n        uint16_t* framebuffer = reinterpret_cast<uint16_t*>(destination) + offset;\n        const uint16_t* const lineend = framebuffer + count;\n        if (alpha == 0xFF)\n        {\n            do\n            {\n                if (widgetX++ & 2)\n                {\n                    *framebuffer = 0xF800;\n                }\n            } while (++framebuffer < lineend);\n        }\n        else\n        {\n            do\n            {\n                if (widgetX++ & 2)\n                {\n                    *framebuffer = alphaBlend(0xF800, *framebuffer, alpha);\n                }\n            } while (++framebuffer < lineend);\n        }\n    }\n};\n")),(0,a.kt)("p",null,"The stripes are now correctly oriented:"),(0,a.kt)(i.Z,{imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/stripe-painter-rotate90-fixed.png",mdxType:"Figure"},"The StripePainterRotate90 painting a Circle."),(0,a.kt)("h2",f({},{id:"filling-rule"}),"Filling Rule"),(0,a.kt)("p",null,"On the Shape widget it is possible to select between two filling\nrules: ",(0,a.kt)("em",{parentName:"p"},"Fill-Non-Zero")," or ",(0,a.kt)("em",{parentName:"p"},"Fill-Even-Odd"),". The Fill-Non-Zero rule is\nthe default rule. The two figures below illustrate the difference\nbetween the two fill rules:"),(0,a.kt)(i.Z,{width:"45%",imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/filling-rule-even-odd.png",mdxType:"Figure"},"Painting a start Shape using the Fill-Even-Odd rule"),(0,a.kt)(i.Z,{width:"45%",imageSource:"/img/development/ui-development/touchgfx-engine-features/canvas-widgets/filling-rule-non-zero.png",mdxType:"Figure"},"Painting a start Shape using the Fill-Non-Zero rule"),(0,a.kt)("p",null,"The Even-Odd rule does not paint pixels that you can reach from the\noutside by crossing an even number (here zero or two) of edges."),(0,a.kt)("p",null,"The Non-Zero rule counts the number of edges going left-to-right on\nthe path to a pixel and subtracting the number of edges going\nright-to-left. If the count is non-zero the pixel is painted."),(0,a.kt)("p",null,"The fill rule can easily be set in code:"),(0,a.kt)("pre",null,(0,a.kt)("code",f({parentName:"pre"},{className:"language-cpp"}),"    touchgfx::Shape<5> shape1;\n    ....\n    shape1.setFillingRule(Rasterizer::FILL_EVEN_ODD);\n")),(0,a.kt)(r.Z,{mdxType:"FurtherReading"},"Wikipedia article on ",(0,a.kt)(l.Z,{to:"https://en.wikipedia.org/wiki/Nonzero-rule",mdxType:"Link"},"Nonzero-rule")))}x.isMDXComponent=!0}}]);